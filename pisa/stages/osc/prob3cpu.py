# authors: T.Arlen, J.Lanfranchi, P.Eller
# date:   March 20, 2016

from itertools import izip, product
from operator import setitem

import numpy as np

from pisa import ureg, Q_
from pisa.core.binning import MultiDimBinning
from pisa.core.stage import Stage
from pisa.core.transform import BinnedTensorTransform, TransformSet
from pisa.utils.resources import find_resource
from pisa.stages.osc.prob3.BargerPropagator import BargerPropagator
from pisa.utils.log import logging
from pisa.utils.comparisons import normQuant
from pisa.utils.profiler import profile


__all__ = ['prob3cpu']


SIGFIGS = 12
"""Significant figures for determining if numbers and quantities normalised
(using pisa.utils.comparisons.normQuant) are equal. Make sure this is less than
the numerical precision that calculations are being performed in to have the
desired effect that "essentially equal" things evaluate to be equal."""


class prob3cpu(Stage):
    """Neutrino oscillations calculation via Prob3.

    Parameters
    ----------
    params : ParamSet
        All of the following param names (and no more) must be in `params`.
        Earth parameters:
            * earth_model : str (resource location with earth model file)
            * YeI : float (electron fraction, inner core)
            * YeM : float (electron fraction, mantle)
            * YeO : float (electron fraction, outer core)
        Detector parameters:
            * detector_depth : float >= 0
            * prop_height
        Oscillation parameters:
            * deltacp
            * deltam21
            * deltam31
            * theta12
            * theta13
            * theta23
        Nutau (and nutaubar) normalization:
            * nutau_norm


    input_binning : MultiDimBinning
    output_binning : MultiDimBinning
    transforms_cache_depth : int >= 0
    outputs_cache_depth : int >= 0
    debug_mode : bool

    Input Names
    -----------
    The `inputs` container must include objects with `name` attributes:
      * 'nue'
      * 'numu'
      * 'nuebar'
      * 'numubar'

    Output Names
    ------------
    The `outputs` container generated by this service will be objects with the
    following `name` attribute:
      * 'nue'
      * 'numu'
      * 'nutau'
      * 'nuebar'
      * 'numubar'
      * 'nutaubar'

    """
    def __init__(self, params, input_binning, output_binning,
                 memcache_deepcopy, error_method, transforms_cache_depth,
                 outputs_cache_depth, debug_mode=None):
        expected_params = (
            'earth_model', 'YeI', 'YeM', 'YeO',
            'detector_depth', 'prop_height',
            'deltacp', 'deltam21', 'deltam31',
            'theta12', 'theta13', 'theta23',
            'nutau_norm'
        )

        # Define the names of objects that are required by this stage (objects
        # will have the attribute `name`: i.e., obj.name)
        input_names = (
            'nue', 'numu', 'nuebar', 'numubar'
        )

        # Define the names of objects that get produced by this stage
        output_names = (
            'nue', 'numu', 'nutau', 'nuebar', 'numubar', 'nutaubar'
        )

        # Invoke the init method from the parent class (Stage), which does a
        # lot of work (caching, providing public interfaces, etc.)
        super(self.__class__, self).__init__(
            use_transforms=True,
            params=params,
            expected_params=expected_params,
            input_names=input_names,
            output_names=output_names,
            error_method=error_method,
            outputs_cache_depth=outputs_cache_depth,
            memcache_deepcopy=memcache_deepcopy,
            transforms_cache_depth=transforms_cache_depth,
            input_binning=input_binning,
            output_binning=output_binning,
            debug_mode=debug_mode
        )

        self.compute_binning_constants()

    def compute_binning_constants(self):
        # Only works if energy and coszen are in input_binning
        if 'true_energy' not in self.input_binning \
                or 'true_coszen' not in self.input_binning:
            raise ValueError(
                'Input binning must contain both "true_energy" and'
                ' "true_coszen" dimensions.'
            )

        # Not handling rebinning (or oversampling)
        assert self.input_binning == self.output_binning

        # Get the energy/coszen (ONLY) weighted centers here, since these
        # are actually used in the oscillations computation. All other
        # dimensions are ignored. Since these won't change so long as the
        # binning doesn't change, attache these to self.
        self.ecz_binning = MultiDimBinning([
            self.input_binning.true_energy.to('GeV'),
            self.input_binning.true_coszen.to('dimensionless')
        ])
        e_centers, cz_centers = self.ecz_binning.weighted_centers
        self.e_centers = e_centers.magnitude
        self.cz_centers = cz_centers.magnitude

        self.num_czbins = self.input_binning.true_coszen.num_bins
        self.num_ebins = self.input_binning.true_energy.num_bins

        self.e_dim_num = self.input_binning.names.index('true_energy')
        self.cz_dim_num = self.input_binning.names.index('true_coszen')

        self.extra_dim_nums = range(self.input_binning.num_dims)
        [self.extra_dim_nums.remove(d) for d in (self.e_dim_num,
                                                 self.cz_dim_num)]

    def create_transforms_datastructs(self):
        xform_shape = [3, 2] + list(self.input_binning.shape)
        nu_xform = np.empty(xform_shape)
        antinu_xform = np.empty(xform_shape)
        return nu_xform, antinu_xform

    def setup_barger_propagator(self):
        # If already instantiated with same parameters, don't instantiate again
        if (hasattr(self, 'barger_propagator')
            and hasattr(self, '_barger_earth_model')
            and hasattr(self, '_barger_detector_depth')
            and normQuant(self._barger_detector_depth, sigfigs=SIGFIGS)
                == normQuant(self.params.detector_depth.m_as('km'),
                             sigfigs=SIGFIGS)
            and self.params.earth_model.value == self._barger_earth_model):
            return

        # Some private variables to keep track of the state of the barger
        # propagator that has been instantiated, so if it is requested to be
        # instantiated again with equivalent parameters, this step can be
        # skipped (see checks above).
        self._barger_detector_depth = self.params.detector_depth.m_as('km')
        self._barger_earth_model = self.params.earth_model.value

        # TODO: can we pass kwargs to swig-ed C++ code?
        self.barger_propagator = BargerPropagator(
            find_resource(self._barger_earth_model),
            self._barger_detector_depth
        )
        self.barger_propagator.UseMassEigenstates(False)

    def _derive_nominal_transforms_hash(self):
        """No nominal transforms implemented for this service."""
        return None

    @profile
    def _compute_transforms(self):
        """Compute oscillation transforms using Prob3 CPU code."""
        self.setup_barger_propagator()

        # Read parameters in, convert to the units used internally for
        # computation, and then strip the units off. Note that this also
        # enforces compatible units (but does not sanity-check the numbers).
        theta12 = self.params.theta12.m_as('rad')
        theta13 = self.params.theta13.m_as('rad')
        theta23 = self.params.theta23.m_as('rad')
        deltam21 = self.params.deltam21.m_as('eV**2')
        deltam31 = self.params.deltam31.m_as('eV**2')
        deltacp = self.params.deltacp.m_as('rad')
        YeI = self.params.YeI.m_as('dimensionless')
        YeO = self.params.YeO.m_as('dimensionless')
        YeM = self.params.YeM.m_as('dimensionless')
        prop_height = self.params.prop_height.m_as('km')
        nutau_norm = self.params.nutau_norm.m_as('dimensionless')

        sin2th12Sq = np.sin(theta12)**2
        sin2th13Sq = np.sin(theta13)**2
        sin2th23Sq = np.sin(theta23)**2

        total_bins = int(len(self.e_centers)*len(self.cz_centers))
        evals = np.empty(total_bins, "double")
        czvals = np.empty(total_bins, "double")

        # We use 18 since we have 3*3 possible oscillations for each of
        # neutrinos and antineutrinos.
        prob_list = np.empty(total_bins*18, dtype='double')

        # The 1.0 was energyscale from earlier versions. Perhaps delete this
        # if we no longer want energyscale.
        prob_list, evals, czvals = self.barger_propagator.fill_osc_prob_c(
            self.e_centers, self.cz_centers, 1.0,
            deltam21, deltam31, deltacp,
            prop_height,
            YeI, YeO, YeM,
            total_bins*18, total_bins, total_bins,
            theta12, theta13, theta23
        )

        # Slice up the transform arrays into views to populate each transform
        dims = ['true_energy', 'true_coszen']
        xform_dim_indices = [0, 1]
        users_dim_indices = [self.input_binning.index(d) for d in dims]
        xform_shape = [2] + [self.input_binning[d].num_bins for d in dims]

        # TODO: populate explicitly by flavor, don't assume any particular
        # ordering of the outputs names!
        transforms = []
        for out_idx, output_name in enumerate(self.output_names):
            xform = np.empty(xform_shape)
            if out_idx < 3:
                # Neutrinos
                xform[0] = np.array([
                    prob_list[out_idx + i*18*self.num_czbins
                              : out_idx + 18*(i+1)*self.num_czbins
                              : 18]
                    for i in range(0, self.num_ebins)
                ])
                xform[1] = np.array([
                    prob_list[out_idx+3 + i*18*self.num_czbins
                              : out_idx + 18*(i+1)*self.num_czbins
                              : 18]
                    for i in range(0, self.num_ebins)
                ])
                input_names = self.input_names[0:2]

            else:
                # Antineutrinos
                xform[0] = np.array([
                    prob_list[out_idx+6 + i*18*self.num_czbins
                              : out_idx+6 + 18*(i+1)*self.num_czbins
                              : 18]
                    for i in range(0, self.num_ebins)
                ])
                xform[1] = np.array([
                    prob_list[out_idx+9 + i*18*self.num_czbins
                              : out_idx+9 + 18*(i+1)*self.num_czbins
                              : 18]
                    for i in range(0, self.num_ebins)
                ])
                input_names = self.input_names[2:4]

            xform = np.moveaxis(
                xform,
                source=[0] + [i+1 for i in xform_dim_indices],
                destination=[0] + [i+1 for i in users_dim_indices]
            )
            if nutau_norm != 1 and output_name in ['nutau', 'nutaubar']:
                xform *= nutau_norm
            transforms.append(
                BinnedTensorTransform(
                    input_names=input_names,
                    output_name=output_name,
                    input_binning=self.input_binning,
                    output_binning=self.output_binning,
                    xform_array=xform
                )
            )

        return TransformSet(transforms=transforms)

    def validate_params(self, params):
        pass
